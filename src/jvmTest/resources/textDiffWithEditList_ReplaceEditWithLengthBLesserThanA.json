{"oldFileText":"package io.gitlab.arturbosch.detekt\n\nimport io.gitlab.arturbosch.detekt.extensions.DetektExtension\nimport org.gradle.api.GradleException\nimport org.gradle.api.Plugin\nimport org.gradle.api.Project\nimport org.gradle.api.file.FileCollection\nimport org.gradle.api.internal.HasConvention\nimport org.gradle.api.plugins.JavaPluginConvention\nimport org.gradle.api.plugins.ReportingBasePlugin\nimport org.gradle.api.provider.Provider\nimport org.gradle.api.reporting.ReportingExtension\nimport org.gradle.api.tasks.SourceSet\nimport org.gradle.language.base.plugins.LifecycleBasePlugin\nimport org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet\nimport java.io.File\n\nclass DetektPlugin : Plugin<Project> {\n\n    override fun apply(project: Project) {\n        project.pluginManager.apply(ReportingBasePlugin::class.java)\n        val extension = project.extensions.create(DETEKT_TASK_NAME, DetektExtension::class.java, project)\n        extension.reportsDir = project.extensions.getByType(ReportingExtension::class.java).file(\"detekt\")\n\n        val defaultConfigFile =\n            project.file(\"${project.rootProject.layout.projectDirectory.dir(CONFIG_DIR_NAME)}/$CONFIG_FILE\")\n        if (defaultConfigFile.exists()) {\n            extension.config = project.files(defaultConfigFile)\n        }\n\n        configurePluginDependencies(project, extension)\n        setTaskDefaults(project)\n\n        registerOldDetektTask(project, extension)\n        registerDetektTasks(project, extension)\n        registerCreateBaselineTask(project, extension)\n        registerGenerateConfigTask(project)\n    }\n\n    private fun registerDetektTasks(project: Project, extension: DetektExtension) {\n        // Kotlin JVM plugin\n        project.plugins.withId(\"org.jetbrains.kotlin.jvm\") {\n            project.afterEvaluate {\n                project.convention.getPlugin(JavaPluginConvention::class.java).sourceSets.all { sourceSet ->\n                    registerDetektTask(project, extension, sourceSet)\n                }\n            }\n        }\n    }\n\n    private fun registerOldDetektTask(project: Project, extension: DetektExtension) {\n        val detektTaskProvider = project.tasks.register(DETEKT_TASK_NAME, Detekt::class.java) {\n            it.debugProp.set(project.provider { extension.debug })\n            it.parallelProp.set(project.provider { extension.parallel })\n            it.disableDefaultRuleSetsProp.set(project.provider { extension.disableDefaultRuleSets })\n            it.buildUponDefaultConfigProp.set(project.provider { extension.buildUponDefaultConfig })\n            it.failFastProp.set(project.provider { extension.failFast })\n            it.autoCorrectProp.set(project.provider { extension.autoCorrect })\n            it.config.setFrom(project.provider { extension.config })\n            it.baseline.set(project.layout.file(project.provider { extension.baseline }))\n            it.setSource(existingInputDirectoriesProvider(project, extension))\n            it.setIncludes(defaultIncludes)\n            it.setExcludes(defaultExcludes)\n            it.reportsDir.set(project.provider { extension.customReportsDir })\n            it.reports = extension.reports\n            it.ignoreFailuresProp.set(project.provider { extension.ignoreFailures })\n        }\n\n        project.tasks.matching { it.name == LifecycleBasePlugin.CHECK_TASK_NAME }.configureEach {\n            it.dependsOn(detektTaskProvider)\n        }\n    }\n\n    private fun registerDetektTask(project: Project, extension: DetektExtension, sourceSet: SourceSet) {\n        val kotlinSourceSet = (sourceSet as HasConvention).convention.plugins[\"kotlin\"] as? KotlinSourceSet\n            ?: throw GradleException(\"Kotlin source set not found. Please report on detekt's issue tracker\")\n        project.tasks.register(DETEKT_TASK_NAME + sourceSet.name.capitalize(), Detekt::class.java) {\n            it.debugProp.set(project.provider { extension.debug })\n            it.parallelProp.set(project.provider { extension.parallel })\n            it.disableDefaultRuleSetsProp.set(project.provider { extension.disableDefaultRuleSets })\n            it.buildUponDefaultConfigProp.set(project.provider { extension.buildUponDefaultConfig })\n            it.failFastProp.set(project.provider { extension.failFast })\n            it.autoCorrectProp.set(project.provider { extension.autoCorrect })\n            it.config.setFrom(project.provider { extension.config })\n            it.baseline.set(project.layout.file(project.provider { extension.baseline }))\n            it.setSource(kotlinSourceSet.kotlin.files)\n            it.classpath.setFrom(sourceSet.compileClasspath, sourceSet.output.classesDirs)\n            it.reports.xml.destination = File(extension.reportsDir, sourceSet.name + \".xml\")\n            it.reports.html.destination = File(extension.reportsDir, sourceSet.name + \".html\")\n            it.reports.txt.destination = File(extension.reportsDir, sourceSet.name + \".txt\")\n            it.ignoreFailuresProp.set(project.provider { extension.ignoreFailures })\n            it.description =\n                \"EXPERIMENTAL & SLOW: Run detekt analysis for ${sourceSet.name} classes with type resolution\"\n        }\n    }\n\n    private fun registerCreateBaselineTask(project: Project, extension: DetektExtension) =\n        project.tasks.register(BASELINE, DetektCreateBaselineTask::class.java) {\n            it.baseline.set(project.layout.file(project.provider { extension.baseline }))\n            it.config.setFrom(project.provider { extension.config })\n            it.debug.set(project.provider { extension.debug })\n            it.parallel.set(project.provider { extension.parallel })\n            it.disableDefaultRuleSets.set(project.provider { extension.disableDefaultRuleSets })\n            it.buildUponDefaultConfig.set(project.provider { extension.buildUponDefaultConfig })\n            it.failFast.set(project.provider { extension.failFast })\n            it.autoCorrect.set(project.provider { extension.autoCorrect })\n            it.setSource(existingInputDirectoriesProvider(project, extension))\n            it.setIncludes(defaultIncludes)\n            it.setExcludes(defaultExcludes)\n        }\n\n    private fun registerGenerateConfigTask(project: Project) =\n        project.tasks.register(GENERATE_CONFIG, DetektGenerateConfigTask::class.java)\n\n    private fun existingInputDirectoriesProvider(\n        project: Project,\n        extension: DetektExtension\n    ): Provider<FileCollection> = project.provider { extension.input.filter { it.exists() } }\n\n    private fun configurePluginDependencies(project: Project, extension: DetektExtension) {\n        project.configurations.create(CONFIGURATION_DETEKT_PLUGINS) { configuration ->\n            configuration.isVisible = false\n            configuration.isTransitive = true\n            configuration.description = \"The $CONFIGURATION_DETEKT_PLUGINS libraries to be used for this project.\"\n        }\n\n        project.configurations.create(CONFIGURATION_DETEKT) { configuration ->\n            configuration.isVisible = false\n            configuration.isTransitive = true\n            configuration.description = \"The $CONFIGURATION_DETEKT dependencies to be used for this project.\"\n\n            configuration.defaultDependencies { dependencySet ->\n                val version = extension.toolVersion ?: DEFAULT_DETEKT_VERSION\n                dependencySet.add(project.dependencies.create(\"io.gitlab.arturbosch.detekt:detekt-cli:$version\"))\n            }\n        }\n    }\n\n    private fun setTaskDefaults(project: Project) {\n        project.tasks.withType(Detekt::class.java).configureEach {\n            it.detektClasspath.setFrom(project.configurations.getAt(CONFIGURATION_DETEKT))\n            it.pluginClasspath.setFrom(project.configurations.getAt(CONFIGURATION_DETEKT_PLUGINS))\n        }\n\n        project.tasks.withType(DetektCreateBaselineTask::class.java).configureEach {\n            it.detektClasspath.setFrom(project.configurations.getAt(CONFIGURATION_DETEKT))\n            it.pluginClasspath.setFrom(project.configurations.getAt(CONFIGURATION_DETEKT_PLUGINS))\n        }\n\n        project.tasks.withType(DetektGenerateConfigTask::class.java).configureEach {\n            it.detektClasspath.setFrom(project.configurations.getAt(CONFIGURATION_DETEKT))\n        }\n    }\n\n    companion object {\n        private const val DETEKT_TASK_NAME = \"detekt\"\n        private const val GENERATE_CONFIG = \"detektGenerateConfig\"\n        private const val BASELINE = \"detektBaseline\"\n        private val defaultExcludes = listOf(\"build/\")\n        private val defaultIncludes = listOf(\"**/*.kt\", \"**/*.kts\")\n        internal const val CONFIG_DIR_NAME = \"config/detekt\"\n        internal const val CONFIG_FILE = \"detekt.yml\"\n    }\n}\n\nconst val CONFIGURATION_DETEKT = \"detekt\"\nconst val CONFIGURATION_DETEKT_PLUGINS = \"detektPlugins\"\n","newFileText":"package io.gitlab.arturbosch.detekt\n\nimport com.android.build.gradle.AppExtension\nimport com.android.build.gradle.BaseExtension\nimport com.android.build.gradle.LibraryExtension\nimport com.android.build.gradle.TestedExtension\nimport com.android.build.gradle.api.BaseVariant\nimport com.android.build.gradle.internal.api.TestedVariant\nimport com.android.build.gradle.internal.tasks.factory.dependsOn\nimport io.gitlab.arturbosch.detekt.extensions.DetektExtension\nimport org.gradle.api.DomainObjectSet\nimport org.gradle.api.GradleException\nimport org.gradle.api.Plugin\nimport org.gradle.api.Project\nimport org.gradle.api.file.FileCollection\nimport org.gradle.api.internal.HasConvention\nimport org.gradle.api.plugins.JavaPluginConvention\nimport org.gradle.api.plugins.ReportingBasePlugin\nimport org.gradle.api.provider.Provider\nimport org.gradle.api.reporting.ReportingExtension\nimport org.gradle.api.tasks.SourceSet\nimport org.gradle.api.tasks.TaskProvider\nimport org.gradle.language.base.plugins.LifecycleBasePlugin\nimport org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet\nimport java.io.File\n\n@Suppress(\"TooManyFunctions\")\nclass DetektPlugin : Plugin<Project> {\n\n    override fun apply(project: Project) {\n        project.pluginManager.apply(ReportingBasePlugin::class.java)\n        val extension = project.extensions.create(DETEKT_TASK_NAME, DetektExtension::class.java, project)\n        extension.reportsDir = project.extensions.getByType(ReportingExtension::class.java).file(\"detekt\")\n\n        val defaultConfigFile =\n            project.file(\"${project.rootProject.layout.projectDirectory.dir(CONFIG_DIR_NAME)}/$CONFIG_FILE\")\n        if (defaultConfigFile.exists()) {\n            extension.config = project.files(defaultConfigFile)\n        }\n\n        configurePluginDependencies(project, extension)\n        setTaskDefaults(project)\n\n        project.registerOldDetektTask(extension)\n        project.registerDetektTasks(extension)\n        project.registerCreateBaselineTask(extension)\n        project.registerGenerateConfigTask()\n    }\n\n    private fun Project.registerDetektTasks(extension: DetektExtension) {\n        project.plugins.withId(\"kotlin-android\") {\n            // There is not a single Android plugin, but each registers an extension based on BaseExtension,\n            // so we catch them all by looking for this one\n            project.afterEvaluate {\n                val androidExtension = project.extensions.findByType(BaseExtension::class.java)\n                androidExtension?.let {\n                    val mainTaskProvider = project.tasks.register(\"${DETEKT_TASK_NAME}Main\") {\n                        it.group = \"verification\"\n                        it.description = \"EXPERIMENTAL & SLOW: Run detekt analysis for production classes across \" +\n                                \"all variants with type resolution\"\n                    }\n                    val testTaskProvider = project.tasks.register(\"${DETEKT_TASK_NAME}Test\") {\n                        it.group = \"verification\"\n                        it.description = \"EXPERIMENTAL & SLOW: Run detekt analysis for test classes across \" +\n                                \"all variants with type resolution\"\n                    }\n                    val bootClasspath = files(androidExtension.bootClasspath)\n                    androidExtension.variants?.all { variant ->\n                        project.registerAndroidDetektTask(bootClasspath, extension, variant).also { provider ->\n                            mainTaskProvider.dependsOn(provider)\n                        }\n                        variant.testVariants.forEach { testVariant ->\n                            project.registerAndroidDetektTask(bootClasspath, extension, testVariant).also { provider ->\n                                testTaskProvider.dependsOn(provider)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Kotlin JVM plugin\n        project.plugins.withId(\"org.jetbrains.kotlin.jvm\") {\n            project.afterEvaluate {\n                project.convention.getPlugin(JavaPluginConvention::class.java).sourceSets.all { sourceSet ->\n                    project.registerJvmDetektTask(extension, sourceSet)\n                }\n            }\n        }\n    }\n\n    private val BaseExtension.variants: DomainObjectSet<out BaseVariant>?\n        get() = when (this) {\n            is AppExtension -> applicationVariants\n            is LibraryExtension -> libraryVariants\n            is TestedExtension -> testVariants\n            else -> null\n        }\n\n    private val BaseVariant.testVariants: List<BaseVariant>\n        get() = if (this is TestedVariant) listOfNotNull(testVariant, unitTestVariant)\n        else emptyList()\n\n    private fun Project.registerOldDetektTask(extension: DetektExtension) {\n        val detektTaskProvider = tasks.register(DETEKT_TASK_NAME, Detekt::class.java) {\n            it.debugProp.set(project.provider { extension.debug })\n            it.parallelProp.set(project.provider { extension.parallel })\n            it.disableDefaultRuleSetsProp.set(project.provider { extension.disableDefaultRuleSets })\n            it.buildUponDefaultConfigProp.set(project.provider { extension.buildUponDefaultConfig })\n            it.failFastProp.set(project.provider { extension.failFast })\n            it.autoCorrectProp.set(project.provider { extension.autoCorrect })\n            it.config.setFrom(project.provider { extension.config })\n            it.baseline.set(project.layout.file(project.provider { extension.baseline }))\n            it.setSource(existingInputDirectoriesProvider(project, extension))\n            it.setIncludes(defaultIncludes)\n            it.setExcludes(defaultExcludes)\n            it.reportsDir.set(project.provider { extension.customReportsDir })\n            it.reports = extension.reports\n            it.ignoreFailuresProp.set(project.provider { extension.ignoreFailures })\n        }\n\n        tasks.matching { it.name == LifecycleBasePlugin.CHECK_TASK_NAME }.configureEach {\n            it.dependsOn(detektTaskProvider)\n        }\n    }\n\n    private fun Project.registerAndroidDetektTask(\n        bootClasspath: FileCollection,\n        extension: DetektExtension,\n        variant: BaseVariant\n    ): TaskProvider<Detekt> =\n        registerDetektTask(DETEKT_TASK_NAME + variant.name.capitalize(), extension) {\n            setSource(variant.sourceSets.map { it.javaDirectories })\n            classpath.setFrom(variant.getCompileClasspath(null) + bootClasspath)\n            reports.xml.destination = File(extension.reportsDir, variant.name + \".xml\")\n            reports.html.destination = File(extension.reportsDir, variant.name + \".html\")\n            reports.txt.destination = File(extension.reportsDir, variant.name + \".txt\")\n            description = \"EXPERIMENTAL & SLOW: Run detekt analysis for ${variant.name} classes with type resolution\"\n        }\n\n    private fun Project.registerJvmDetektTask(extension: DetektExtension, sourceSet: SourceSet) {\n        val kotlinSourceSet = (sourceSet as HasConvention).convention.plugins[\"kotlin\"] as? KotlinSourceSet\n            ?: throw GradleException(\"Kotlin source set not found. Please report on detekt's issue tracker\")\n        registerDetektTask(DETEKT_TASK_NAME + sourceSet.name.capitalize(), extension) {\n            setSource(kotlinSourceSet.kotlin.files)\n            classpath.setFrom(sourceSet.compileClasspath, sourceSet.output.classesDirs)\n            reports.xml.destination = File(extension.reportsDir, sourceSet.name + \".xml\")\n            reports.html.destination = File(extension.reportsDir, sourceSet.name + \".html\")\n            reports.txt.destination = File(extension.reportsDir, sourceSet.name + \".txt\")\n            description = \"EXPERIMENTAL & SLOW: Run detekt analysis for ${sourceSet.name} classes with type resolution\"\n        }\n    }\n\n    private fun Project.registerDetektTask(\n        name: String,\n        extension: DetektExtension,\n        configuration: Detekt.() -> Unit\n    ): TaskProvider<Detekt> =\n        tasks.register(name, Detekt::class.java) {\n            it.debugProp.set(provider { extension.debug })\n            it.parallelProp.set(provider { extension.parallel })\n            it.disableDefaultRuleSetsProp.set(provider { extension.disableDefaultRuleSets })\n            it.buildUponDefaultConfigProp.set(provider { extension.buildUponDefaultConfig })\n            it.failFastProp.set(provider { extension.failFast })\n            it.autoCorrectProp.set(provider { extension.autoCorrect })\n            it.config.setFrom(provider { extension.config })\n            it.baseline.set(layout.file(project.provider { extension.baseline }))\n            it.ignoreFailuresProp.set(project.provider { extension.ignoreFailures })\n            configuration(it)\n        }\n\n    private fun Project.registerCreateBaselineTask(extension: DetektExtension) =\n        tasks.register(BASELINE, DetektCreateBaselineTask::class.java) {\n            it.baseline.set(project.layout.file(project.provider { extension.baseline }))\n            it.config.setFrom(project.provider { extension.config })\n            it.debug.set(project.provider { extension.debug })\n            it.parallel.set(project.provider { extension.parallel })\n            it.disableDefaultRuleSets.set(project.provider { extension.disableDefaultRuleSets })\n            it.buildUponDefaultConfig.set(project.provider { extension.buildUponDefaultConfig })\n            it.failFast.set(project.provider { extension.failFast })\n            it.autoCorrect.set(project.provider { extension.autoCorrect })\n            it.setSource(existingInputDirectoriesProvider(project, extension))\n            it.setIncludes(defaultIncludes)\n            it.setExcludes(defaultExcludes)\n        }\n\n    private fun Project.registerGenerateConfigTask() =\n        tasks.register(GENERATE_CONFIG, DetektGenerateConfigTask::class.java)\n\n    private fun existingInputDirectoriesProvider(\n        project: Project,\n        extension: DetektExtension\n    ): Provider<FileCollection> = project.provider { extension.input.filter { it.exists() } }\n\n    private fun configurePluginDependencies(project: Project, extension: DetektExtension) {\n        project.configurations.create(CONFIGURATION_DETEKT_PLUGINS) { configuration ->\n            configuration.isVisible = false\n            configuration.isTransitive = true\n            configuration.description = \"The $CONFIGURATION_DETEKT_PLUGINS libraries to be used for this project.\"\n        }\n\n        project.configurations.create(CONFIGURATION_DETEKT) { configuration ->\n            configuration.isVisible = false\n            configuration.isTransitive = true\n            configuration.description = \"The $CONFIGURATION_DETEKT dependencies to be used for this project.\"\n\n            configuration.defaultDependencies { dependencySet ->\n                @Suppress(\"USELESS_ELVIS\")\n                val version = extension.toolVersion ?: DEFAULT_DETEKT_VERSION\n                dependencySet.add(project.dependencies.create(\"io.gitlab.arturbosch.detekt:detekt-cli:$version\"))\n            }\n        }\n    }\n\n    private fun setTaskDefaults(project: Project) {\n        project.tasks.withType(Detekt::class.java).configureEach {\n            it.detektClasspath.setFrom(project.configurations.getAt(CONFIGURATION_DETEKT))\n            it.pluginClasspath.setFrom(project.configurations.getAt(CONFIGURATION_DETEKT_PLUGINS))\n        }\n\n        project.tasks.withType(DetektCreateBaselineTask::class.java).configureEach {\n            it.detektClasspath.setFrom(project.configurations.getAt(CONFIGURATION_DETEKT))\n            it.pluginClasspath.setFrom(project.configurations.getAt(CONFIGURATION_DETEKT_PLUGINS))\n        }\n\n        project.tasks.withType(DetektGenerateConfigTask::class.java).configureEach {\n            it.detektClasspath.setFrom(project.configurations.getAt(CONFIGURATION_DETEKT))\n        }\n    }\n\n    companion object {\n        private const val DETEKT_TASK_NAME = \"detekt\"\n        private const val GENERATE_CONFIG = \"detektGenerateConfig\"\n        private const val BASELINE = \"detektBaseline\"\n        private val defaultExcludes = listOf(\"build/\")\n        private val defaultIncludes = listOf(\"**/*.kt\", \"**/*.kts\")\n        internal const val CONFIG_DIR_NAME = \"config/detekt\"\n        internal const val CONFIG_FILE = \"detekt.yml\"\n    }\n}\n\nconst val CONFIGURATION_DETEKT = \"detekt\"\nconst val CONFIGURATION_DETEKT_PLUGINS = \"detektPlugins\"\n","editList":[{"beginA":2,"beginB":2,"endA":2,"endB":9},{"beginA":3,"beginB":10,"endA":3,"endB":11},{"beginA":13,"beginB":21,"endA":13,"endB":22},{"beginA":17,"beginB":26,"endA":17,"endB":27},{"beginA":33,"beginB":43,"endA":37,"endB":47},{"beginA":39,"beginB":49,"endA":40,"endB":81},{"beginA":44,"beginB":85,"endA":45,"endB":86},{"beginA":50,"beginB":91,"endA":52,"endB":105},{"beginA":68,"beginB":121,"endA":69,"endB":122},{"beginA":73,"beginB":126,"endA":74,"endB":141},{"beginA":76,"beginB":143,"endA":93,"endB":150},{"beginA":96,"beginB":153,"endA":98,"endB":173},{"beginA":111,"beginB":186,"endA":113,"endB":188},{"beginA":132,"beginB":207,"endA":132,"endB":208}]}